# 秒杀系统
## 项目介绍
基于SpringBoot+MyBatisPlus搭建的秒杀系统，针对高并发场景进行了优化，在保证线程安全的同时提高了服务器的吞吐量，
主要优化手段有缓存（页面缓存+对象缓存）、页面静态化、Redis预减库存、RabbitMQ异步下单等，
项目主要实现的功能为登录、商品列表浏览、商品详情页面浏览、秒杀下单。
本项目使用压测工具JMeter对优化前后的性能进行了详细的测试，附带完整的测试报告。
## 开发框架
前端：Thymeleaf + Bootstrap + jQuery 

后端：SpringBoot + MyBatisPlus + MySQL

中间件：Redis + RabbitMQ

## 优化方案
#### 1. 缓存优化
- **页面缓存**：
  将一些用户经常请求，并且更新少的页面，比如商品详情页，存储到redis缓存中，在用户请求的时候直接在缓存中获取并返回，如果取缓存失败，则利用thymeleaf的手动渲染，渲染后存入缓存，并且返回。

- **对象缓存**：
  将用户信息、商品信息、订单信息和token等数据进行缓存。有了用户信息缓存，在需要用户信息的页面，不需要再次登录获取，也不需要通过cookie去数据库中查找，只需要通过cookie在redis中获取用户信息对象。
#### 2. 页面静态化
对页面静态部分直接缓存到用户浏览器，可以减少对redis服务器的请求。只需要利用ajax的异步加载，请求动态数据。

#### 3. 缓存和数据库的一致性
更新的时候，先更新数据库，再删除缓存。可能出现的问题：

读请求对**数据库的操作**在写请求之前，读到旧值，写请求对**缓存的操作**在读请求之前，先删除缓存，然后读请求将读到的旧值写入缓存。

这种情况比较少发生，因为读操作一般比写操作快，所以正常情况下，写请求对**缓存的操作**在读请求之后。

一种比较保险的策略：**延时双删**

先删除缓存——再写数据库——休眠一小段时间，再删除缓存。

#### 4. 内存标记+redis预减库存+RabbitMQ异步下单+客户端轮询
- （对Redis操作前）在秒杀Controller建一个HashMap，用来标记商品是否库存已经为0，如果为0，则直接返回秒杀失败，如果不为0，则查询redis中的库存
- （Redis预处理）在秒杀前，将商品库存数据存到Redis中，在Redis中进行减库存操作，从而减少对数据库的访问
- （应对高流量）用RabbitMQ进行异步下单，请求先进入队列中进行缓冲，异步生成订单，减少数据库库存，同时客户端轮询下单结果。

经过上述三个操作可以减少对数据库的访问，提高并发量。

#### 5. 解决库存超卖
对库存更新时，先对库存判断，只有当库存大于0时，才能更新。

#### 6. 解决重复秒杀
对用户id和商品id建立一个唯一索引，通过这种约束避免同一用户秒杀到两件相同的商品

#### 7. 限流
对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也很重要。此时要使用限流来进行限制同一用户的访问量，当达到限流阈值，后续请求会被降级。项目使用RateLimiter来实现限流，它是guava提供的基于令牌桶算法的限流实现类，通过调整生成token的速率来限制用户频繁访问秒杀页面，从而达到防止超大流量冲垮系统。它能够限制数据的平均传输速率，还允许某种程度的突发传输。在令牌桶算法中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它适合于具有突发特性的流量。

#### 8. 隐藏接口地址
原先的接口地址是"secKill/doSecKill"，项目中对接口地址加入一个动态加密path。这个path是用户的cookie+salt经过MD5加密得到的，不同用户的path不一样，修改后的隐藏地址是"secKill/{path}/doSecKill"

#### 9. 验证码
为了防止恶意脚本造成的高请求量，在用户点击秒杀按钮前需要先输入验证码。
- 前端访问生成验证码的接口
- 后端将访问验证码，并且将答案存到redis中，key是用户id+商品id
- 验证时，从redis中取value，然后将它与用户的输入进行比较

## JMeter测试
测试设置：每次测试的并发线程数为10000，并发循环次数为10


#### 商品列表接口测试
这个接口做了页面缓存的优化，对比结果如下

优化前：
优化后：

#### 秒杀接口测试
这个接口做了对象缓存+页面静态化+redis预减库存+内存标记+rabbitmq异步下单等性能优化，对比结果如下

优化前：
优化后：

#### 页面静态化测试
访问经过页面静态化的商品详情页，可以发现静态资源已经缓存到浏览器中

